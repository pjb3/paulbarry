---
id: 5360
article_id: 4947
created_at: 2009-11-24 23:20:39.000000000 Z
url: http://paulbarry.com
email: mail@paulbarry.com
author: Paul Barry
ip: 70.245.160.121
body: "@Jeremy\n\n> I'll preface this by saying I am no expert on this, but this conflicts
  a bit with how I understood all of this. My understanding is that the first example
  is, indeed, imperative and iterative. The second example is functional and recursive.
  And the third example is functional and iterative.\n\nRight\n\n> My understanding
  of a tail call is when a function is called in a tail position of a function. (ie,
  the last line of a function, or branch...a terminal expression) The tail call can
  be calling the same function but it does not need to be. Tail call optimization
  is then a run-time (or compile-time) optimization where the tail call shares a stack
  frame with the original calling function.\n\nRight\n\n> I don't mean that this contradicts
  what you are saying, but runtime differences between the two functional examples
  have more to do with the first being recursive and the second being iterative. Tail
  call optimization would make this more efficient still, but I don't think that is
  what is being demonstrated.\n\nIn the recursive example, the function call isn't
  in the tail position, therefore it's can't be optimized.  \n\n> I fully realize
  that I could be wrong on this, but I would think that transparently changing from
  a recursive to iterative logic would not be reliably feasible. Well, at least doing
  so is not what I understood TCO to be. Am I way off on this?\n\nRight, I agree,
  I think :)  The interpreter can't do tail call optimization unless the function
  call is in the tail position.  So I think we agree on everything.  Is there something
  specific that I said that you disagree with? \n"
guid: 126f371f-e670-4a94-a9f1-773a6ae52fe5
